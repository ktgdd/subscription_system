diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..471ab03
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,8 @@
+# Changelog
+
+## [Unreleased]
+
+### Added
+- Dev bypass flag (`app.jwt.dev-bypass-enabled`) to skip JWT validation for testing. When enabled, accepts `X-User-Id`, `X-Request-Id`, and `X-Role` headers instead of JWT tokens.
+- Redis idempotency tests for concurrent request handling. Added service-level tests and API integration tests to verify idempotency keys prevent duplicate requests under concurrent load.
+
diff --git a/pom.xml b/pom.xml
index df13d49..a86fcf2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -140,6 +140,11 @@
 			<artifactId>spring-boot-starter-data-redis-reactive-test</artifactId>
 			<scope>test</scope>
 		</dependency>
+		<dependency>
+			<groupId>com.h2database</groupId>
+			<artifactId>h2</artifactId>
+			<scope>test</scope>
+		</dependency>
 	</dependencies>
 
 	<build>
diff --git a/run-idempotency-tests.bat b/run-idempotency-tests.bat
new file mode 100644
index 0000000..f413065
--- /dev/null
+++ b/run-idempotency-tests.bat
@@ -0,0 +1,4 @@
+@echo off
+REM Run idempotency tests
+call mvn test -Dtest=IdempotencyServiceTest,IdempotencyApiTest
+
diff --git a/run-idempotency-tests.sh b/run-idempotency-tests.sh
new file mode 100755
index 0000000..026f8fc
--- /dev/null
+++ b/run-idempotency-tests.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+# Run idempotency tests
+mvn test -Dtest=IdempotencyServiceTest,IdempotencyApiTest
+
diff --git a/src/main/java/com/example/subscription/config/AppProperties.java b/src/main/java/com/example/subscription/config/AppProperties.java
index 1a96b2c..86c008c 100644
--- a/src/main/java/com/example/subscription/config/AppProperties.java
+++ b/src/main/java/com/example/subscription/config/AppProperties.java
@@ -88,6 +88,7 @@ public class AppProperties {
         private String requestIdClaim = "request_id";
         private boolean debugMode = false;
         private boolean debugSkipExpiryValidation = false;
+        private boolean devBypassEnabled = false;
 
         public String getSecret() {
             return secret;
@@ -144,6 +145,14 @@ public class AppProperties {
         public void setDebugSkipExpiryValidation(boolean debugSkipExpiryValidation) {
             this.debugSkipExpiryValidation = debugSkipExpiryValidation;
         }
+
+        public boolean isDevBypassEnabled() {
+            return devBypassEnabled;
+        }
+
+        public void setDevBypassEnabled(boolean devBypassEnabled) {
+            this.devBypassEnabled = devBypassEnabled;
+        }
     }
 
     public static class Rules {
diff --git a/src/main/java/com/example/subscription/config/RedisConfig.java b/src/main/java/com/example/subscription/config/RedisConfig.java
index f4d2e6d..c167726 100644
--- a/src/main/java/com/example/subscription/config/RedisConfig.java
+++ b/src/main/java/com/example/subscription/config/RedisConfig.java
@@ -11,6 +11,7 @@ import org.springframework.data.redis.serializer.StringRedisSerializer;
 public class RedisConfig {
 
     @Bean
+    @org.springframework.context.annotation.Primary
     public ReactiveRedisTemplate<String, String> reactiveRedisTemplate(ReactiveRedisConnectionFactory connectionFactory) {
         StringRedisSerializer serializer = new StringRedisSerializer();
         RedisSerializationContext<String, String> serializationContext = 
diff --git a/src/main/java/com/example/subscription/middleware/JwtAuthInterceptor.java b/src/main/java/com/example/subscription/middleware/JwtAuthInterceptor.java
index 15992b4..48eeba2 100644
--- a/src/main/java/com/example/subscription/middleware/JwtAuthInterceptor.java
+++ b/src/main/java/com/example/subscription/middleware/JwtAuthInterceptor.java
@@ -15,6 +15,7 @@ import org.springframework.web.servlet.HandlerInterceptor;
 import io.jsonwebtoken.ExpiredJwtException;
 import javax.crypto.SecretKey;
 import java.nio.charset.StandardCharsets;
+import java.util.UUID;
 
 @Component
 @RequiredArgsConstructor
@@ -25,6 +26,22 @@ public class JwtAuthInterceptor implements HandlerInterceptor {
 
     @Override
     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
+        // dev bypass for testing
+        if (appProperties.getJwt().isDevBypassEnabled()) {
+            String userId = request.getHeader("X-User-Id");
+            String reqId = request.getHeader("X-Request-Id");
+            String role = request.getHeader("X-Role");
+            
+            if (userId != null) {
+                request.setAttribute("userId", Long.parseLong(userId));
+                request.setAttribute("role", role != null ? role : "USER");
+                // generate request id if not provided
+                String finalReqId = reqId != null ? reqId : UUID.randomUUID().toString();
+                request.setAttribute("requestId", finalReqId);
+                return true;
+            }
+        }
+        
         String authHeader = request.getHeader("Authorization");
         
         if (authHeader == null || !authHeader.startsWith("Bearer ")) {
diff --git a/src/main/resources/application.properties b/src/main/resources/application.properties
index 792e413..36daba4 100644
--- a/src/main/resources/application.properties
+++ b/src/main/resources/application.properties
@@ -24,6 +24,7 @@ app.jwt.role-claim=role
 app.jwt.request-id-claim=request_id
 app.jwt.debug-mode=false
 app.jwt.debug-skip-expiry-validation=false
+app.jwt.dev-bypass-enabled=false
 
 # Business Rules (Defaults - can be overridden by rules_engine table)
 app.rules.max-extension-days=730
diff --git a/src/test/java/com/example/subscription/SubscriptionApplicationTests.java b/src/test/java/com/example/subscription/SubscriptionApplicationTests.java
index e909036..2b804ff 100644
--- a/src/test/java/com/example/subscription/SubscriptionApplicationTests.java
+++ b/src/test/java/com/example/subscription/SubscriptionApplicationTests.java
@@ -2,8 +2,10 @@ package com.example.subscription;
 
 import org.junit.jupiter.api.Test;
 import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.test.context.ActiveProfiles;
 
 @SpringBootTest
+@ActiveProfiles("test")
 class SubscriptionApplicationTests {
 
 	@Test
diff --git a/src/test/java/com/example/subscription/controller/IdempotencyApiTest.java b/src/test/java/com/example/subscription/controller/IdempotencyApiTest.java
new file mode 100644
index 0000000..2a3fa41
--- /dev/null
+++ b/src/test/java/com/example/subscription/controller/IdempotencyApiTest.java
@@ -0,0 +1,211 @@
+package com.example.subscription.controller;
+
+import com.example.subscription.dto.request.SubscribeRequest;
+import com.example.subscription.model.*;
+import com.example.subscription.repository.*;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.data.redis.core.ReactiveRedisTemplate;
+import org.springframework.http.MediaType;
+import org.springframework.test.context.ActiveProfiles;
+import org.springframework.test.web.servlet.MockMvc;
+import org.springframework.web.context.WebApplicationContext;
+
+import java.math.BigDecimal;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
+import static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;
+
+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
+@ActiveProfiles("test")
+class IdempotencyApiTest {
+
+    @Autowired
+    private WebApplicationContext webApplicationContext;
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    @Autowired
+    private SubscriptionPlanRepository subscriptionPlanRepository;
+
+    @Autowired
+    private SubscriptionAccountRepository subscriptionAccountRepository;
+
+    @Autowired
+    private DurationTypeRepository durationTypeRepository;
+
+    @Autowired
+    private BookKeepingRepository bookKeepingRepository;
+
+    @Autowired
+    private ReactiveRedisTemplate<String, String> redisTemplate;
+
+    private MockMvc mockMvc;
+    private SubscriptionAccount testAccount;
+    private DurationType testDurationType;
+    private SubscriptionPlan testPlan;
+    private Long testUserId = 123L;
+
+    @BeforeEach
+    void setUp() {
+        mockMvc = webAppContextSetup(webApplicationContext).build();
+
+        // cleanup old data
+        bookKeepingRepository.deleteAll();
+        subscriptionPlanRepository.deleteAll();
+        subscriptionAccountRepository.deleteAll();
+        durationTypeRepository.deleteAll();
+        
+        // clear redis
+        redisTemplate.keys("idempotency:*")
+                .flatMap(key -> redisTemplate.delete(key))
+                .blockLast();
+
+        // create test account
+        testAccount = new SubscriptionAccount();
+        testAccount.setName("Test Netflix");
+        testAccount.setIsActive(true);
+        testAccount = subscriptionAccountRepository.save(testAccount);
+
+        // create duration type
+        testDurationType = new DurationType();
+        testDurationType.setType("MONTHLY");
+        testDurationType.setDays(30);
+        testDurationType = durationTypeRepository.save(testDurationType);
+
+        // create plan
+        testPlan = new SubscriptionPlan();
+        testPlan.setSubscriptionAccountId(testAccount.getId());
+        testPlan.setDurationTypeId(testDurationType.getId());
+        testPlan.setAmount(new BigDecimal("9.99"));
+        testPlan.setCurrency("USD");
+        testPlan.setName("Basic Plan");
+        testPlan.setIsActive(true);
+        testPlan = subscriptionPlanRepository.save(testPlan);
+    }
+
+    @Test
+    void testSubscribeWithSameRequestId_SecondRequestFails() throws Exception {
+        String requestId = UUID.randomUUID().toString();
+        SubscribeRequest request = new SubscribeRequest();
+        request.setSubscriptionPlanId(testPlan.getId());
+
+        // first request should work
+        mockMvc.perform(post("/api/subscriptions")
+                        .header("X-User-Id", testUserId.toString())
+                        .header("X-Request-Id", requestId)
+                        .header("X-Role", "USER")
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(objectMapper.writeValueAsString(request)))
+                .andExpect(status().isAccepted());
+
+        // same request id should be rejected
+        mockMvc.perform(post("/api/subscriptions")
+                        .header("X-User-Id", testUserId.toString())
+                        .header("X-Request-Id", requestId)
+                        .header("X-Role", "USER")
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(objectMapper.writeValueAsString(request)))
+                .andExpect(result -> {
+                    int status = result.getResponse().getStatus();
+                    assertTrue(status == 400 || status == 409, "Expected 400 or 409, got " + status);
+                });
+    }
+
+    @Test
+    void testConcurrentRequestsSameRequestId() throws Exception {
+        // test that concurrent requests with same request id only allow one
+        String requestId = UUID.randomUUID().toString();
+        int numThreads = 10;
+        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+        CountDownLatch latch = new CountDownLatch(numThreads);
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger failCount = new AtomicInteger(0);
+
+        SubscribeRequest request = new SubscribeRequest();
+        request.setSubscriptionPlanId(testPlan.getId());
+
+        for (int i = 0; i < numThreads; i++) {
+            executor.submit(() -> {
+                try {
+                    mockMvc.perform(post("/api/subscriptions")
+                                    .header("X-User-Id", testUserId.toString())
+                                    .header("X-Request-Id", requestId)
+                                    .header("X-Role", "USER")
+                                    .contentType(MediaType.APPLICATION_JSON)
+                                    .content(objectMapper.writeValueAsString(request)))
+                            .andExpect(result -> {
+                                int status = result.getResponse().getStatus();
+                                if (status == 202) {
+                                    successCount.incrementAndGet();
+                                } else if (status == 400 || status == 409) {
+                                    failCount.incrementAndGet();
+                                }
+                            });
+                } catch (Exception e) {
+                    // swallow exceptions for now
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+
+        latch.await();
+        executor.shutdown();
+
+        // only one should succeed
+        assertEquals(1, successCount.get());
+        assertEquals(numThreads - 1, failCount.get());
+    }
+
+    @Test
+    void testConcurrentRequestsDifferentRequestIds() throws Exception {
+        // different request ids should all work
+        int numThreads = 10;
+        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+        CountDownLatch latch = new CountDownLatch(numThreads);
+        AtomicInteger successCount = new AtomicInteger(0);
+
+        SubscribeRequest request = new SubscribeRequest();
+        request.setSubscriptionPlanId(testPlan.getId());
+
+        for (int i = 0; i < numThreads; i++) {
+            final String requestId = UUID.randomUUID().toString();
+            executor.submit(() -> {
+                try {
+                    mockMvc.perform(post("/api/subscriptions")
+                                    .header("X-User-Id", testUserId.toString())
+                                    .header("X-Request-Id", requestId)
+                                    .header("X-Role", "USER")
+                                    .contentType(MediaType.APPLICATION_JSON)
+                                    .content(objectMapper.writeValueAsString(request)))
+                            .andExpect(result -> {
+                                if (result.getResponse().getStatus() == 202) {
+                                    successCount.incrementAndGet();
+                                }
+                            });
+                } catch (Exception e) {
+                    // ignore errors
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+
+        latch.await();
+        executor.shutdown();
+
+        assertEquals(numThreads, successCount.get());
+    }
+}
+
diff --git a/src/test/java/com/example/subscription/service/IdempotencyServiceTest.java b/src/test/java/com/example/subscription/service/IdempotencyServiceTest.java
new file mode 100644
index 0000000..aeee124
--- /dev/null
+++ b/src/test/java/com/example/subscription/service/IdempotencyServiceTest.java
@@ -0,0 +1,158 @@
+package com.example.subscription.service;
+
+import com.example.subscription.config.AppProperties;
+import com.example.subscription.exception.ErrorCode;
+import com.example.subscription.exception.SubscriptionException;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.data.redis.core.ReactiveRedisTemplate;
+import org.springframework.test.context.ActiveProfiles;
+import reactor.test.StepVerifier;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+@SpringBootTest
+@ActiveProfiles("test")
+class IdempotencyServiceTest {
+
+    @Autowired
+    private IdempotencyService idempotencyService;
+    
+    @Autowired
+    private ReactiveRedisTemplate<String, String> redisTemplate;
+    
+    @Autowired
+    private AppProperties appProperties;
+
+    @BeforeEach
+    void setUp() {
+        // cleanup redis keys before each test
+        redisTemplate.keys("idempotency:*")
+                .flatMap(key -> redisTemplate.delete(key))
+                .blockLast();
+    }
+
+    @Test
+    void testFirstRequestSucceeds() {
+        String key = "test-key-1";
+        
+        StepVerifier.create(idempotencyService.checkAndSet(key))
+                .expectNext(true)
+                .verifyComplete();
+    }
+
+    @Test
+    void testDuplicateRequestFails() {
+        String key = "test-key-2";
+        
+        idempotencyService.checkAndSet(key).block();
+        
+        // second request should fail
+        StepVerifier.create(idempotencyService.checkAndSet(key))
+                .expectErrorMatches(e -> 
+                    e instanceof SubscriptionException &&
+                    ((SubscriptionException) e).getErrorCode() == ErrorCode.DUPLICATE_REQUEST
+                )
+                .verify();
+    }
+
+    @Test
+    void testDifferentKeysWork() {
+        String key1 = "key1";
+        String key2 = "key2";
+        
+        idempotencyService.checkAndSet(key1).block();
+        idempotencyService.checkAndSet(key2).block();
+        
+        // both should work
+        assertTrue(idempotencyService.exists(key1).block());
+        assertTrue(idempotencyService.exists(key2).block());
+    }
+
+    @Test
+    void testConcurrentRequestsWithSameKey() throws InterruptedException {
+        // main test - concurrent requests with same key should only allow one
+        String key = "concurrent-key";
+        int numThreads = 10;
+        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+        CountDownLatch latch = new CountDownLatch(numThreads);
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger failCount = new AtomicInteger(0);
+
+        for (int i = 0; i < numThreads; i++) {
+            executor.submit(() -> {
+                try {
+                    Boolean result = idempotencyService.checkAndSet(key).block();
+                    if (result != null && result) {
+                        successCount.incrementAndGet();
+                    }
+                } catch (SubscriptionException e) {
+                    failCount.incrementAndGet();
+                } catch (Exception e) {
+                    // ignore
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+
+        latch.await();
+        executor.shutdown();
+
+        assertEquals(1, successCount.get());
+        assertEquals(numThreads - 1, failCount.get());
+    }
+
+    @Test
+    void testConcurrentRequestsWithDifferentKeys() throws InterruptedException {
+        // different keys should all succeed
+        int numThreads = 10;
+        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+        CountDownLatch latch = new CountDownLatch(numThreads);
+        AtomicInteger successCount = new AtomicInteger(0);
+
+        for (int i = 0; i < numThreads; i++) {
+            final String key = "key-" + i;
+            executor.submit(() -> {
+                try {
+                    idempotencyService.checkAndSet(key).block();
+                    successCount.incrementAndGet();
+                } catch (Exception e) {
+                    // shouldn't happen
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+
+        latch.await();
+        executor.shutdown();
+
+        assertEquals(numThreads, successCount.get());
+    }
+
+    @Test
+    void testKeyExpiresAfterTTL() throws InterruptedException {
+        String key = "ttl-key";
+        
+        idempotencyService.checkAndSet(key).block();
+        assertTrue(idempotencyService.exists(key).block());
+        
+        // wait for ttl to expire
+        int ttl = appProperties.getIdempotency().getRedisTtlSeconds();
+        Thread.sleep((ttl + 1) * 1000);
+        
+        assertFalse(idempotencyService.exists(key).block());
+        
+        // should be able to set again after expiry
+        idempotencyService.checkAndSet(key).block();
+    }
+}
+
diff --git a/src/test/resources/application-test.properties b/src/test/resources/application-test.properties
new file mode 100644
index 0000000..10b36b4
--- /dev/null
+++ b/src/test/resources/application-test.properties
@@ -0,0 +1,74 @@
+spring.application.name=subscription-test
+
+# Database Configuration (H2 in-memory for tests)
+spring.datasource.url=jdbc:h2:mem:testdb
+spring.datasource.driver-class-name=org.h2.Driver
+spring.datasource.username=sa
+spring.datasource.password=
+spring.jpa.hibernate.ddl-auto=create-drop
+spring.jpa.show-sql=false
+spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
+spring.h2.console.enabled=false
+
+# Redis Configuration
+spring.data.redis.host=localhost
+spring.data.redis.port=6379
+spring.data.redis.password=
+spring.data.redis.timeout=2000ms
+
+# JWT Configuration
+app.jwt.secret=your-secret-key-change-in-production-test-key-min-32-chars
+app.jwt.expiration=3600000
+app.jwt.user-id-claim=user_id
+app.jwt.role-claim=role
+app.jwt.request-id-claim=request_id
+app.jwt.debug-mode=true
+app.jwt.debug-skip-expiry-validation=true
+app.jwt.dev-bypass-enabled=true
+
+# Business Rules
+app.rules.max-extension-days=730
+app.rules.cooldown-seconds=10
+app.rules.max-subscription-duration-days=730
+
+# Payment Service Configuration
+app.payment.service.url=http://localhost:8081/api/payments
+app.payment.service.timeout=5000
+app.payment.service.retry.max-attempts=3
+app.payment.service.retry.delay=2000
+app.payment.service.circuit-breaker.failure-threshold=5
+app.payment.service.circuit-breaker.wait-duration=60000
+
+# Observability
+app.observability.logging.level=INFO
+app.observability.metrics.enabled=true
+app.observability.tracing.enabled=false
+
+# Actuator Configuration
+management.endpoints.web.exposure.include=health,metrics
+management.endpoint.health.show-details=when-authorized
+
+# Logging Configuration
+logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %5p [%t] %c{1} : %m%n
+logging.level.com.example.subscription=INFO
+
+# Thread Pool Configuration
+app.thread-pool.core-size=5
+app.thread-pool.max-size=10
+app.thread-pool.queue-capacity=100
+
+# Cache Configuration
+app.cache.subscription-plans.ttl=3600
+app.cache.subscription-plans.enabled=true
+
+# Idempotency
+app.idempotency.redis-ttl-seconds=10
+
+# Kafka Configuration (disable for tests or use embedded)
+spring.kafka.bootstrap-servers=localhost:9092
+spring.kafka.consumer.group-id=subscription-service-group-test
+spring.kafka.consumer.auto-offset-reset=earliest
+
+# Kafka Topics
+app.kafka.topic.book-keeping=book-keeping-events-test
+
